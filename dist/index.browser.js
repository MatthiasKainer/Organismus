!function(e){const o={};var r;(r=e.LOGLEVEL||(e.LOGLEVEL={}))[r.SILENT=0]="SILENT",r[r.ERROR=1]="ERROR",r[r.INFO=80]="INFO",r[r.DEBUG=90]="DEBUG",r[r.TRACE=100]="TRACE";let n=e.LOGLEVEL.SILENT;let t=[];const s=(o,r,...s)=>{t.forEach(n=>n(e.LOGLEVEL.ERROR,o,r,...s)),n>=e.LOGLEVEL.ERROR&&console.error(r,o,...s)},a=(o,r,...s)=>{if(t.forEach(n=>n(e.LOGLEVEL.INFO,o,r,...s)),n>=e.LOGLEVEL.INFO){(n===e.LOGLEVEL.TRACE?console.trace:console.log)(r,o,...s)}},i=(o,r,...s)=>{if(t.forEach(n=>n(e.LOGLEVEL.DEBUG,o,r,...s)),n>=e.LOGLEVEL.DEBUG){(n===e.LOGLEVEL.TRACE?console.trace:console.log)(r,o,...s)}},c={queue:{},list:{}};function l(e){return e.reduce((e,o)=>`${e};${o.name};`,"")}const m=new class{constructor(){this.actionDictionary={}}on(e,o){if(Array.isArray(e)){const r=l(e);if(c.list[r])throw s("Hypothalamus.on",new Error("Cannot register the same list of hormones twice"),r),new Error("Cannot register the same list of hormones twice");a("[Hypothalamus.on] Adding new action when all in a list of hormones are released",r,e),c.list[r]={hormones:[...e],callback:o}}else a("Hypothalamus.on","Adding new action when a hormone is released",e.name),this.actionDictionary[e.name]=this.actionDictionary[e.name]||[],this.actionDictionary[e.name].push(o)}drop(e){Array.isArray(e)?(i("Hypothalamus.drop","Dropping a list of hormones",l(e),e),delete c.queue[l(e)],delete c.list[l(e)]):(i("Hypothalamus.drop","Dropping a hormone",e.name),this.actionDictionary[e.name]=[])}dropAll(){i("Hypothalamus.dropAll","Dropping all hormones"),this.actionDictionary={},c.queue={},c.list={}}orchestrate(e,o){this.actionDictionary[e.name]&&this.actionDictionary[e.name].forEach(e=>e(o));const r=Object.keys(c.queue).filter(o=>o.indexOf(`;${e.name};`)>-1);let n=Object.keys(c.list).filter(o=>o.indexOf(`;${e.name};`)>-1&&r.every(e=>e!==o));n.forEach(e=>{c.queue[e]={hormones:[...c.list[e].hormones],values:{},callback:c.list[e].callback}});const t=[...new Set([...r,...n])];for(let r=0;r<t.length;r++){const n=t[r];c.queue[n].hormones=c.queue[n].hormones.filter(o=>o.name!==e.name),c.queue[n].values[e.name]=o,c.queue[n].hormones.length<1&&(c.queue[n].callback(c.queue[n].values),delete c.queue[n])}}};e.defineHormone=function(e,r={}){if(o[e]&&!r.loadIfExists)throw s("hormone.defineHormone",new Error("Hormone already created"),e),new Error("Hormone already created");if(o[e]&&r.loadIfExists)return i("hormone.defineHormone","Hormone already created, reusing existing",e),{name:e};const{defaultValue:n,transformation:t,readOnce:a}=r;return o[e]={name:e,value:n,defaultValue:n,transformation:t,receptors:[],readOnce:null!=a&&a},{name:e}},e.hypothalamus=m,e.releaseHormone=async function({name:e},r){if(!o[e])throw s("hormone.releaseHormone",new Error("Hormone does not exist"),e),new Error("Hormone does not exist");var n;n=r,o[e].value=void 0===n||n instanceof Function?void 0===r||r(o[e].value):r,a("hormone.releaseHormone","Releasing passed hormone",e,o[e].value);const{receptors:t,transformation:c}=o[e];return t.filter(r=>{const n=void 0===r.onlyIf||r.onlyIf(o[e].value);return i("hormone.releaseHormone",n?"Keeping receptor because condition matched or no condition":"Filtered receptor from the triggers because condition not matched",r),n}).forEach(({element:e})=>e.requestUpdate()),c&&c(o[e].value),m.orchestrate({name:e},o[e].value),await Promise.all(t.map(e=>e.element.updateComplete)),o[e].readOnce&&(i("hormone.releaseHormone","Resetting hormone because it is readOnce",e),o[e].value=o[e].defaultValue),Object.assign({},o[e])},e.setLoglevel=e=>n=e,e.useReceptor=function(r,{name:i},c){if(!o[i])throw s("receptor.useReceptor",new Error("Hormone is not defined"),i),new Error(`Hormone "${i}" is not defined`);return((e,r,n)=>!o[r].receptors.some(o=>{var r;return o.element===e&&(null===(r=o.onlyIf)||void 0===r?void 0:r.toString())===(null==n?void 0:n.toString())}))(r,i,c)?(a("receptor.useReceptor","Pushing new receptor to hormone",i,{element:r}),o[i].receptors.push({element:r,onlyIf:c})):((o,r,...s)=>{t.forEach(n=>n(e.LOGLEVEL.TRACE,o,r,...s)),n===e.LOGLEVEL.TRACE&&console.trace(r,o,...s)})("receptor.useReceptor","Receptor not pushed because already subscribed",i,{element:r}),!c||c(o[i].value)?o[i].value:void 0}}({});
