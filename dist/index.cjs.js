Object.defineProperty(exports,"o",{value:!0});const e={};var o;exports.LOGLEVEL=void 0,(o=exports.LOGLEVEL||(exports.LOGLEVEL={}))[o.SILENT=0]="SILENT",o[o.ERROR=1]="ERROR",o[o.INFO=80]="INFO",o[o.DEBUG=90]="DEBUG",o[o.TRACE=100]="TRACE";let r=exports.LOGLEVEL.SILENT;let n=[];const t=(e,o,...t)=>{n.forEach((r=>r(exports.LOGLEVEL.ERROR,e,o,...t))),r>=exports.LOGLEVEL.ERROR&&console.error(o,e,...t)},s=(e,o,...t)=>{if(n.forEach((r=>r(exports.LOGLEVEL.INFO,e,o,...t))),r>=exports.LOGLEVEL.INFO){(r===exports.LOGLEVEL.TRACE?console.trace:console.log)(o,e,...t)}},a=(e,o,...t)=>{if(n.forEach((r=>r(exports.LOGLEVEL.DEBUG,e,o,...t))),r>=exports.LOGLEVEL.DEBUG){(r===exports.LOGLEVEL.TRACE?console.trace:console.log)(o,e,...t)}},c={queue:{},list:{}};function i(e){return e.reduce(((e,o)=>`${e};${o.name};`),"")}const l=new class{constructor(){this.actionDictionary={}}on(e,o){if(Array.isArray(e)){const r=i(e);if(c.list[r])throw t("Hypothalamus.on",new Error("Cannot register the same list of hormones twice"),r),new Error("Cannot register the same list of hormones twice");s("[Hypothalamus.on] Adding new action when all in a list of hormones are released",r,e),c.list[r]={hormones:[...e],callback:o}}else s("Hypothalamus.on","Adding new action when a hormone is released",e.name),this.actionDictionary[e.name]=this.actionDictionary[e.name]||[],this.actionDictionary[e.name].push(o)}drop(e){Array.isArray(e)?(a("Hypothalamus.drop","Dropping a list of hormones",i(e),e),delete c.queue[i(e)],delete c.list[i(e)]):(a("Hypothalamus.drop","Dropping a hormone",e.name),this.actionDictionary[e.name]=[])}dropAll(){a("Hypothalamus.dropAll","Dropping all hormones"),this.actionDictionary={},c.queue={},c.list={}}collect(e,o,r){const n=`collect;;${e.name};${o.name};`;if(c.list[n])throw t("Hypothalamus.collect",new Error("Cannot register the same list of hormones twice"),n),new Error("Cannot register the same list of hormones twice");s("[Hypothalamus.collect] Adding new action when collected hormones are released",n,e,o),c.list[n]={hormones:[o],callback:r}}orchestrate(e,o){this.actionDictionary[e.name]&&this.actionDictionary[e.name].forEach((e=>e(o)));const r=Object.keys(c.queue).filter((o=>o.includes(`;${e.name};`))),n=Object.keys(c.list).filter((o=>o.indexOf(`;${e.name};`)>-1&&r.every((e=>e!==o))));n.forEach((e=>{c.queue[e]={hormones:[...c.list[e].hormones],values:{},callback:c.list[e].callback}}));const t=[...new Set([...r,...n])];for(let r=0;r<t.length;r++){const n=t[r];if(n.startsWith("collect;;")){const[r]=n.replace("collect;;","").split(";");e.name===r?c.queue[n].values[e.name]=[...c.queue[n].values[e.name]||[],o]:(c.queue[n].values[e.name]=o,c.queue[n].callback(c.queue[n].values),delete c.queue[n])}else c.queue[n].hormones=c.queue[n].hormones.filter((o=>o.name!==e.name)),c.queue[n].values[e.name]=o,c.queue[n].hormones.length<1&&(c.queue[n].callback(c.queue[n].values),delete c.queue[n])}}};function m(o,r={}){return d(e)(o,r)}const d=e=>(o,r={})=>{if(e[o]&&!r.loadIfExists)throw t("hormone.defineHormone",new Error("Hormone already created"),o),new Error("Hormone already created");if(e[o]&&r.loadIfExists)return a("hormone.defineHormone","Hormone already created, reusing existing",o),{name:o};const{defaultValue:n,transformation:s,readOnce:c}=r;return e[o]={name:o,value:n,defaultValue:n,transformation:s,receptors:[],readOnce:null!=c&&c},{name:o}};const p=e=>async(o,r)=>{if(!o)throw t("hormone.releaseHormone",new Error("Hormone cannot be undefined")),new Error("Hormone cannot be undefined");const{name:n}=o;if(!e[n])throw t("hormone.releaseHormone",new Error("Hormone does not exist"),n),new Error("Hormone does not exist");var c;c=r,e[n].value=(void 0===c||c instanceof Function)&&r?r(e[n].value):r,s("hormone.releaseHormone","Releasing passed hormone",n,e[n].value);const{receptors:i,transformation:m}=e[n];m&&m(e[n].value);const d=e[n].value;return l.orchestrate({name:n},d),await Promise.all(i.filter((e=>{const o=void 0===e.onlyIf||e.onlyIf(d);return a("hormone.releaseHormone",o?"Keeping receptor because condition matched or no condition":"Filtered receptor from the triggers because condition not matched",e),o})).map((e=>(null==e?void 0:e.onTriggered)?null==e?void 0:e.onTriggered(d):d))),e[n].readOnce&&(a("hormone.releaseHormone","Resetting hormone because it is readOnce",n),e[n].value=e[n].defaultValue),Object.assign({},e[n])};const u=e=>(o,{name:a},c,i)=>{const l=null!=i?i:c,m=i?c:void 0;if(!e[a])throw t("receptor.useReceptor",new Error("Hormone is not defined"),a),new Error(`Hormone "${a}" is not defined`);((e,o,r,n)=>{const t=(null==n?void 0:n.toString())||r;return!e[r].receptors.some((e=>e.parent===o&&e.key===t))})(e,o,a,m)?(s("receptor.useReceptor","Pushing new receptor to hormone",a,{parent:o}),e[a].receptors.push({key:(null==m?void 0:m.toString())||a,parent:o,onlyIf:m,onTriggered:l}),void 0!==e[a].value?l(e[a].value):void 0!==e[a].defaultValue&&l(e[a].defaultValue)):((e,o,...t)=>{n.forEach((r=>r(exports.LOGLEVEL.TRACE,e,o,...t))),r===exports.LOGLEVEL.TRACE&&console.trace(o,e,...t)})("receptor.useReceptor","Receptor not pushed because already subscribed",a,{parent:o})};exports.Organismus=function(){const e={};return{defineHormone:d(e),releaseHormone:p(e),useReceptor:u(e)}},exports.defineHormone=m,exports.defineSingleHormone=function(e,o={}){return m(e,Object.assign(Object.assign({},o),{readOnce:!0}))},exports.getOrDefineHormone=function(o,r={}){return d(e)(o,Object.assign(Object.assign({},r),{loadIfExists:!0}))},exports.hypothalamus=l,exports.releaseHormone=async function(o,r){return p(e)(o,r)},exports.setLoglevel=e=>r=e,exports.useReceptor=function(o,{name:r},n,t){return u(e)(o,{name:r},n,t)};
