Object.defineProperty(exports,"o",{value:!0});const e={};var o;(o=exports.LOGLEVEL||(exports.LOGLEVEL={}))[o.SILENT=0]="SILENT",o[o.ERROR=1]="ERROR",o[o.INFO=80]="INFO",o[o.DEBUG=90]="DEBUG",o[o.TRACE=100]="TRACE";let r=exports.LOGLEVEL.SILENT;let n=[];const t=(e,o,...t)=>{n.forEach(r=>r(exports.LOGLEVEL.ERROR,e,o,...t)),r>=exports.LOGLEVEL.ERROR&&console.error(o,e,...t)},s=(e,o,...t)=>{if(n.forEach(r=>r(exports.LOGLEVEL.INFO,e,o,...t)),r>=exports.LOGLEVEL.INFO){(r===exports.LOGLEVEL.TRACE?console.trace:console.log)(o,e,...t)}},a=(e,o,...t)=>{if(n.forEach(r=>r(exports.LOGLEVEL.DEBUG,e,o,...t)),r>=exports.LOGLEVEL.DEBUG){(r===exports.LOGLEVEL.TRACE?console.trace:console.log)(o,e,...t)}},i={queue:{},list:{}};function l(e){return e.reduce((e,o)=>`${e};${o.name};`,"")}const c=new class{constructor(){this.actionDictionary={}}on(e,o){if(Array.isArray(e)){const r=l(e);if(i.list[r])throw t("Hypothalamus.on",new Error("Cannot register the same list of hormones twice"),r),new Error("Cannot register the same list of hormones twice");s("[Hypothalamus.on] Adding new action when all in a list of hormones are released",r,e),i.list[r]={hormones:[...e],callback:o}}else s("Hypothalamus.on","Adding new action when a hormone is released",e.name),this.actionDictionary[e.name]=this.actionDictionary[e.name]||[],this.actionDictionary[e.name].push(o)}drop(e){Array.isArray(e)?(a("Hypothalamus.drop","Dropping a list of hormones",l(e),e),delete i.queue[l(e)],delete i.list[l(e)]):(a("Hypothalamus.drop","Dropping a hormone",e.name),this.actionDictionary[e.name]=[])}dropAll(){a("Hypothalamus.dropAll","Dropping all hormones"),this.actionDictionary={},i.queue={},i.list={}}orchestrate(e,o){this.actionDictionary[e.name]&&this.actionDictionary[e.name].forEach(e=>e(o));const r=Object.keys(i.queue).filter(o=>o.indexOf(`;${e.name};`)>-1);let n=Object.keys(i.list).filter(o=>o.indexOf(`;${e.name};`)>-1&&r.every(e=>e!==o));n.forEach(e=>{i.queue[e]={hormones:[...i.list[e].hormones],values:{},callback:i.list[e].callback}});const t=[...new Set([...r,...n])];for(let r=0;r<t.length;r++){const n=t[r];i.queue[n].hormones=i.queue[n].hormones.filter(o=>o.name!==e.name),i.queue[n].values[e.name]=o,i.queue[n].hormones.length<1&&(i.queue[n].callback(i.queue[n].values),delete i.queue[n])}}};exports.defineHormone=function(o,r={}){if(e[o]&&!r.loadIfExists)throw t("hormone.defineHormone",new Error("Hormone already created"),o),new Error("Hormone already created");if(e[o]&&r.loadIfExists)return a("hormone.defineHormone","Hormone already created, reusing existing",o),{name:o};const{defaultValue:n,transformation:s,readOnce:i}=r;return e[o]={name:o,value:n,defaultValue:n,transformation:s,receptors:[],readOnce:null!=i&&i},{name:o}},exports.hypothalamus=c,exports.releaseHormone=async function({name:o},r){if(!e[o])throw t("hormone.releaseHormone",new Error("Hormone does not exist"),o),new Error("Hormone does not exist");var n;n=r,e[o].value=void 0===n||n instanceof Function?void 0===r||r(e[o].value):r,s("hormone.releaseHormone","Releasing passed hormone",o,e[o].value);const{receptors:i,transformation:l}=e[o];return i.filter(r=>{const n=void 0===r.onlyIf||r.onlyIf(e[o].value);return a("hormone.releaseHormone",n?"Keeping receptor because condition matched or no condition":"Filtered receptor from the triggers because condition not matched",r),n}).forEach(({element:e})=>e.requestUpdate()),l&&l(e[o].value),c.orchestrate({name:o},e[o].value),await Promise.all(i.map(e=>e.element.updateComplete)),e[o].readOnce&&(a("hormone.releaseHormone","Resetting hormone because it is readOnce",o),e[o].value=e[o].defaultValue),Object.assign({},e[o])},exports.setLoglevel=e=>r=e,exports.useReceptor=function(o,{name:a},i){if(!e[a])throw t("receptor.useReceptor",new Error("Hormone is not defined"),a),new Error(`Hormone "${a}" is not defined`);return((o,r,n)=>!e[r].receptors.some(e=>{var r;return e.element===o&&(null===(r=e.onlyIf)||void 0===r?void 0:r.toString())===(null==n?void 0:n.toString())}))(o,a,i)?(s("receptor.useReceptor","Pushing new receptor to hormone",a,{element:o}),e[a].receptors.push({element:o,onlyIf:i})):((e,o,...t)=>{n.forEach(r=>r(exports.LOGLEVEL.TRACE,e,o,...t)),r===exports.LOGLEVEL.TRACE&&console.trace(o,e,...t)})("receptor.useReceptor","Receptor not pushed because already subscribed",a,{element:o}),!i||i(e[a].value)?e[a].value:void 0};
